# unsafeコードを小さなモジュールに封じ込める

## 説明

`unsafe`コードがある場合は、unsafeコードの上に最小限の安全なインターフェースを構築するために
必要な不変条件を維持できる可能な限り小さなモジュールを作成します。
これを、安全なコードのみを含み、エルゴノミックなインターフェースを提供する、
より大きなモジュールに埋め込みます。外側のモジュールには、unsafeコードを直接呼び出す
unsafe関数やメソッドを含めることができることに注意してください。
ユーザーはこれを使用して速度上の利点を得ることができます。

## 利点

- 監査が必要なunsafeコードを制限します
- 内部モジュールの保証に頼れるため、外部モジュールの記述がはるかに簡単になります

## 欠点

- 適切なインターフェースを見つけるのが難しい場合があります
- 抽象化により非効率性が生じる可能性があります

## 例

- [`toolshed`](https://docs.rs/toolshed)クレートは、unsafe操作をサブモジュールに含め、
  ユーザーに安全なインターフェースを提供しています。
- `std`の`String`クラスは、内容が有効なUTF-8でなければならないという追加の不変条件を持つ
  `Vec<u8>`のラッパーです。`String`の操作はこの動作を保証します。
  ただし、ユーザーは`unsafe`メソッドを使用して`String`を作成するオプションがあり、
  その場合、内容の有効性を保証する責任はユーザーにあります。

## 参照

- [Ralf JungのunsafeコードにおけるinvariantsについてのBlog](https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html)