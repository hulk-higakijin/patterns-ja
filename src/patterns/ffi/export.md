# オブジェクトベースのAPI

## 説明

他の言語に公開されるRustのAPIを設計する際、通常のRust API設計とは異なる重要な設計原則があります：

1. すべてのカプセル化された型は、Rustによって*所有*され、ユーザーによって*管理*され、
   *不透明*であるべきです。
2. すべてのトランザクショナルなデータ型は、ユーザーによって*所有*され、
   *透明*であるべきです。
3. すべてのライブラリの動作は、カプセル化された型に作用する関数であるべきです。
4. すべてのライブラリの動作は、構造ではなく*出所/ライフタイム*に基づいた型に
   カプセル化されるべきです。

## 動機

Rustには他の言語への組み込みFFIサポートがあります。これは、クレート作成者が異なるABIを通じて
C互換のAPIを提供する方法を提供することで実現されています（ただし、この実践には重要ではありません）。

適切に設計されたRust FFIは、C APIの設計原則に従いながら、Rustの設計を可能な限り
妥協しないようにします。外部APIには3つの目標があります：

1. ターゲット言語で使いやすくする
2. 可能な限りRust側での内部的なunsafeをAPIが指示することを避ける
3. メモリの安全性の欠如とRustの`未定義動作`の可能性を可能な限り小さくする

Rustコードは、ある時点を超えて外部言語のメモリ安全性を信頼する必要があります。
しかし、Rust側の`unsafe`コードはすべて、バグの機会や`未定義動作`を悪化させる機会です。

例えば、ポインタの出所が間違っている場合、無効なメモリアクセスによるセグメンテーション違反になる
可能性があります。しかし、unsafeコードによって操作された場合、本格的なヒープ破損になる可能性があります。

オブジェクトベースのAPI設計により、良好なメモリ安全特性を持ち、何が安全で何が`unsafe`かの
きれいな境界を持つシムを書くことができます。

## コード例

POSIX標準は、[DBM](https://web.archive.org/web/20210105035602/https://www.mankier.com/0p/ndbm.h)
として知られるファイル上のデータベースにアクセスするAPIを定義しています。
これは「オブジェクトベース」APIの優れた例です。

以下はCでの定義で、FFIに関わる人には読みやすいはずです。
以下の解説は、微妙な点を見逃す人のために説明するのに役立つはずです。

```C
struct DBM;
typedef struct { void *dptr, size_t dsize } datum;

int     dbm_clearerr(DBM *);
void    dbm_close(DBM *);
int     dbm_delete(DBM *, datum);
int     dbm_error(DBM *);
datum   dbm_fetch(DBM *, datum);
datum   dbm_firstkey(DBM *);
datum   dbm_nextkey(DBM *);
DBM    *dbm_open(const char *, int, mode_t);
int     dbm_store(DBM *, datum, datum, int);
```

このAPIは2つの型を定義します：`DBM`と`datum`。

`DBM`型は上記で「カプセル化された」型と呼ばれました。内部状態を含むように設計されており、
ライブラリの動作のエントリポイントとして機能します。

ユーザーにとって完全に不透明で、サイズやレイアウトがわからないため、自分で`DBM`を作成できません。
代わりに、`dbm_open`を呼び出す必要があり、それは*それへのポインタ*のみを与えます。

これは、すべての`DBM`がRustの意味でライブラリによって「所有」されていることを意味します。
未知のサイズの内部状態は、ユーザーではなくライブラリによって制御されるメモリに保持されます。
ユーザーは`open`と`close`でライフサイクルを管理し、他の関数で操作を実行できるだけです。

`datum`型は上記で「トランザクショナル」型と呼ばれました。ライブラリとそのユーザー間の
情報交換を促進するように設計されています。

データベースは、事前定義された長さや意味のない「非構造化データ」を格納するように設計されています。
その結果、`datum`はRustスライスのC相当物です：バイトの束と、それらがいくつあるかのカウント。
主な違いは、型情報がないことで、これが`void`が示すものです。

このヘッダーはライブラリの視点から書かれていることに注意してください。
ユーザーはおそらく既知のサイズの型を使用しています。しかし、ライブラリは気にせず、
Cキャストのルールにより、ポインタの背後にある任意の型を`void`にキャストできます。

前述のように、この型はユーザーにとって*透明*です。しかし、この型はユーザーによって*所有*されています。
これには、その中のポインタのために微妙な影響があります。問題は、そのポインタが指すメモリを誰が所有するかです。

最高のメモリ安全性のための答えは「ユーザー」です。しかし、値を取得するような場合、
ユーザーは正しく割り当てる方法を知りません（値の長さがわからないため）。
この場合、ライブラリコードは、ユーザーがアクセスできるヒープ（Cライブラリの`malloc`と`free`など）を
使用し、Rustの意味で*所有権を移転*することが期待されます。

これはすべて推測のように見えるかもしれませんが、これがCでポインタが意味するものです。
Rustと同じことを意味します：「ユーザー定義のライフタイム」。
ライブラリのユーザーは、正しく使用するためにドキュメントを読む必要があります。
とはいえ、ユーザーが間違えた場合の結果が少ない、または大きい決定があります。
それらを最小限に抑えることがこのベストプラクティスの目的であり、鍵は*透明なものすべての所有権を移転する*ことです。

## 利点

これにより、ユーザーが守らなければならないメモリ安全性の保証の数が比較的少数に最小化されます：

1. `dbm_open`によって返されないポインタで関数を呼び出さない（無効なアクセスまたは破損）
2. closeの後にポインタで関数を呼び出さない（解放後使用）
3. 任意の`datum`の`dptr`は`NULL`であるか、広告された長さの有効なメモリスライスを指す必要があります

さらに、多くのポインタ出所の問題を回避します。理由を理解するために、
代替案を詳しく検討してみましょう：キーの反復。

Rustはイテレータで有名です。実装する際、プログラマーは所有者への有界ライフタイムを持つ
別の型を作成し、`Iterator`トレイトを実装します。

`DBM`のRustでの反復の実行方法は次のとおりです：

```rust,ignore
struct Dbm { ... }

impl Dbm {
    /* ... */
    pub fn keys<'it>(&'it self) -> DbmKeysIter<'it> { ... }
    /* ... */
}

struct DbmKeysIter<'it> {
    owner: &'it Dbm,
}

impl<'it> Iterator for DbmKeysIter<'it> { ... }
```

これはRustの保証のおかげで、クリーンで慣用的で安全です。
しかし、簡単なAPI変換がどのように見えるか考えてください：

```rust,ignore
#[no_mangle]
pub extern "C" fn dbm_iter_new(owner: *const Dbm) -> *mut DbmKeysIter {
    // このAPIは悪いアイデアです！実際のアプリケーションには、代わりにオブジェクトベースの設計を使用してください。
}
#[no_mangle]
pub extern "C" fn dbm_iter_next(
    iter: *mut DbmKeysIter,
    key_out: *const datum
) -> libc::c_int {
    // このAPIは悪いアイデアです！実際のアプリケーションには、代わりにオブジェクトベースの設計を使用してください。
}
#[no_mangle]
pub extern "C" fn dbm_iter_del(*mut DbmKeysIter) {
    // このAPIは悪いアイデアです！実際のアプリケーションには、代わりにオブジェクトベースの設計を使用してください。
}
```

このAPIは重要な情報を失います：イテレータのライフタイムは、それを所有する`Dbm`オブジェクトの
ライフタイムを超えてはなりません。ライブラリのユーザーは、イテレータが反復しているデータよりも
長生きする方法で使用する可能性があり、初期化されていないメモリの読み取りを引き起こします。

Cで書かれたこの例には、後で説明されるバグが含まれています：

```C
int count_key_sizes(DBM *db) {
    // この関数を使用しないでください。微妙だが深刻なバグがあります！
    datum key;
    int len = 0;

    if (!dbm_iter_new(db)) {
        dbm_close(db);
        return -1;
    }

    int l;
    while ((l = dbm_iter_next(owner, &key)) >= 0) { // エラーは-1で示される
        free(key.dptr);
        len += key.dsize;
        if (l == 0) { // イテレータの終了
            dbm_close(owner);
        }
    }
    if l >= 0 {
        return -1;
    } else {
        return len;
    }
}
```

このバグは典型的です。イテレータが反復終了マーカーを返すときの動作は次のとおりです：

1. ループ条件が`l`をゼロに設定し、`0 >= 0`のためループに入ります
2. 長さが増分され、この場合はゼロが追加されます
3. if文が真なので、データベースが閉じられます。ここにbreak文があるべきです
4. ループ条件が再度実行され、閉じられたオブジェクトで`next`呼び出しが発生します

このバグの最悪の部分は？Rust実装が慎重であれば、このコードはほとんどの場合動作します！
`Dbm`オブジェクトのメモリがすぐに再利用されない場合、内部チェックはほぼ確実に失敗し、
イテレータはエラーを示す`-1`を返します。しかし、時にはセグメンテーション違反を引き起こしたり、
さらに悪いことに、意味不明なメモリ破損を引き起こしたりします！

これらはRustでは回避できません。その観点から、それらのオブジェクトをヒープに置き、
それらへのポインタを返し、ライフタイムの制御を放棄しました。
Cコードは単に「うまくやる」必要があります。

プログラマーはAPIドキュメントを読んで理解する必要があります。
Cでは当然と考える人もいますが、優れたAPI設計はこのリスクを軽減できます。
`DBM`のPOSIX APIは、イテレータの*所有権を統合*することでこれを行いました：

```C
datum   dbm_firstkey(DBM *);
datum   dbm_nextkey(DBM *);
```

したがって、すべてのライフタイムが一緒に結び付けられ、そのような安全性の欠如が防止されました。

## 欠点

しかし、この設計選択にはいくつかの欠点もあり、同様に考慮する必要があります。

第一に、API自体の表現力が低下します。POSIX DBMでは、オブジェクトごとに1つのイテレータしかなく、
すべての呼び出しがその状態を変更します。これは、安全であっても、ほぼすべての言語のイテレータよりも
はるかに制限的です。おそらく、ライフタイムがより階層的でない他の関連オブジェクトでは、
この制限は安全性よりもコストです。

第二に、APIの部分の関係によっては、かなりの設計努力が必要になる場合があります。
より簡単な設計ポイントの多くには、関連する他のパターンがあります：

- [ラッパー型の統合](./wrappers.md)は、複数のRust型を不透明な「オブジェクト」にグループ化します

- [FFIエラー渡し](../../idioms/ffi/errors.md)は、整数コードとセンチネル戻り値（`NULL`ポインタなど）を
  使用したエラー処理を説明します

- [外部文字列の受け入れ](../../idioms/ffi/accepting-strings.md)は、最小限のunsafeコードで文字列を
  受け入れることができ、[FFIへの文字列の渡し](../../idioms/ffi/passing-strings.md)よりも正しく実装しやすいです

ただし、すべてのAPIをこの方法で実行できるわけではありません。
聴衆が誰であるかについては、プログラマーの最善の判断に委ねられています。