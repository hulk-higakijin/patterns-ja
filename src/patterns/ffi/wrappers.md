# ラッパーへの型統合

## 説明

このパターンは、メモリの安全性の欠如の表面積を最小限に抑えながら、
複数の関連する型を優雅に処理できるように設計されています。

Rustのエイリアシングルールの基礎の1つはライフタイムです。これにより、
型間のアクセスの多くのパターンがメモリ安全であり、データ競合の安全性も含まれることが保証されます。

しかし、Rust型が他の言語にエクスポートされると、通常はポインタに変換されます。
Rustでは、ポインタは「ユーザーがポインティのライフタイムを管理する」ことを意味します。
メモリの安全性の欠如を避けるのは彼らの責任です。

したがって、ユーザーコードに対するある程度の信頼が必要です。特に、Rustが何もできない
解放後使用について注意が必要です。しかし、一部のAPI設計は、他の言語で書かれたコードに
他よりも高い負担をかけます。

最もリスクの低いAPIは「統合ラッパー」で、オブジェクトとのすべての可能な相互作用が
「ラッパー型」に折り込まれ、Rust APIをクリーンに保ちます。

## コード例

これを理解するために、エクスポートするAPIの典型的な例を見てみましょう：
コレクションを通じた反復。

そのAPIは次のようになります：

1. イテレータは`first_key`で初期化されます
2. `next_key`への各呼び出しはイテレータを進めます
3. イテレータが最後にある場合の`next_key`への呼び出しは何もしません
4. 上記のように、イテレータはコレクションに「ラップされます」（ネイティブのRust
   APIとは異なります）

イテレータが`nth()`を効率的に実装している場合、各関数呼び出しに対してエフェメラルにすることができます：

```rust,ignore
struct MySetWrapper {
    myset: MySet,
    iter_next: usize,
}

impl MySetWrapper {
    pub fn first_key(&mut self) -> Option<&Key> {
        self.iter_next = 0;
        self.next_key()
    }
    pub fn next_key(&mut self) -> Option<&Key> {
        if let Some(next) = self.myset.keys().nth(self.iter_next) {
            self.iter_next += 1;
            Some(next)
        } else {
            None
        }
    }
}
```

結果として、ラッパーはシンプルで、`unsafe`コードを含みません。

## 利点

これにより、APIがより安全に使用でき、型間のライフタイムの問題を回避できます。
これが回避する利点と落とし穴の詳細については、[オブジェクトベースのAPI](./export.md)を参照してください。

## 欠点

多くの場合、型のラップは非常に困難であり、時にはRust
APIの妥協が物事を簡単にすることがあります。

例として、`nth()`を効率的に実装しないイテレータを考えてください。
オブジェクトが内部的に反復を処理するための特別なロジックを入れたり、
外部関数APIのみが使用する異なるアクセスパターンを効率的にサポートしたりすることは、
間違いなく価値があります。

### イテレータのラップを試みる（そして失敗する）

任意の型のイテレータをAPIに正しくラップするには、ラッパーはCバージョンのコードが行うことを
する必要があります：イテレータのライフタイムを消去し、手動で管理します。

これが*信じられないほど*困難であることは言うまでもありません。

ここに、*1つの*落とし穴の説明があります。

`MySetWrapper`の最初のバージョンは次のようになります：

```rust,ignore
struct MySetWrapper {
    myset: MySet,
    iter_next: usize,
    // Box<KeysIter + 'self>からtransmuteされて作成
    iterator: Option<NonNull<KeysIter<'static>>>,
}
```

`transmute`がライフタイムを延長するために使用され、ポインタがそれを隠すため、
すでに醜いです。しかし、さらに悪くなります：*他の操作がRustの`未定義動作`を引き起こす可能性があります*。

ラッパー内の`MySet`が、反復中に他の関数によって操作される可能性があることを考えてください。
例えば、反復していたキーに新しい値を格納するなどです。
APIはこれを抑制せず、実際、いくつかの類似のCライブラリはこれを期待しています。

`myset_store`の単純な実装は次のようになります：

```rust,ignore
pub mod unsafe_module {

    // 他のモジュールの内容

    pub fn myset_store(myset: *mut MySetWrapper, key: datum, value: datum) -> libc::c_int {
        // このコードを使用しないでください。問題を示すために安全でありません。

        let myset: &mut MySet = unsafe {
            // SAFETY: おっと、ここでUBが発生します！
            &mut (*myset).myset
        };

        /* ...キーと値のデータをチェックしてキャスト... */

        match myset.store(casted_key, casted_value) {
            Ok(_) => 0,
            Err(e) => e.into(),
        }
    }
}
```

この関数が呼ばれたときにイテレータが存在する場合、Rustのエイリアシングルールの1つに違反しています。
Rustによると、このブロック内の可変参照はオブジェクトへの*排他的*アクセスを持つ必要があります。
イテレータが単に存在する場合、それは排他的ではないため、`未定義動作`があります！[^1]

これを避けるには、可変参照が本当に排他的であることを保証する方法が必要です。
これは基本的に、イテレータの共有参照が存在する間にそれをクリアし、その後再構築することを意味します。
ほとんどの場合、それでもCバージョンよりも効率が悪くなります。

Cがこれをより効率的に行う方法を尋ねる人もいるでしょう。答えは、それがズルをするということです。
Rustのエイリアシングルールが問題であり、Cは単にポインタに対してそれらを無視します。
引き換えに、マニュアルで「スレッドセーフではない」と宣言されているコードを見ることがよくあります。
実際、[GNU Cライブラリ](https://manpages.debian.org/buster/manpages/attributes.7.en.html)には、
並行動作専用の用語集全体があります！

Rustは、安全性とCコードが達成できない最適化の両方のために、すべてを常にメモリ安全にしたいと考えています。
特定のショートカットへのアクセスを拒否されることは、Rustプログラマーが支払う必要がある代償です。

[^1]: 頭を掻いているCプログラマーの皆さんへ、UBを引き起こすためにこのコード*中*にイテレータを
読み取る必要はありません。排他性ルールにより、イテレータの共有参照による一貫性のない観察を
引き起こす可能性のあるコンパイラの最適化も可能になります（例：効率のためのスタックスピルや命令の並べ替え）。
これらの観察は、可変参照が作成された*後のいつでも*発生する可能性があります。
