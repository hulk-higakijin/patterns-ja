# Fold

## 説明

データのコレクション内の各アイテムに対してアルゴリズムを実行して新しいアイテムを作成し、
それによって全く新しいコレクションを作成します。

ここでの語源は私には不明です。「fold」と「folder」という用語はRustコンパイラで使用されていますが、
通常の意味でのfoldよりもmapに近いように見えます。詳細については以下の議論を参照してください。

## 例

```rust,ignore
// foldするデータ、単純なAST
mod ast {
    pub enum Stmt {
        Expr(Box<Expr>),
        Let(Box<Name>, Box<Expr>),
    }

    pub struct Name {
        value: String,
    }

    pub enum Expr {
        IntLit(i64),
        Add(Box<Expr>, Box<Expr>),
        Sub(Box<Expr>, Box<Expr>),
    }
}

// 抽象folder
mod fold {
    use ast::*;

    pub trait Folder {
        // リーフノードは単にノード自体を返します。場合によっては、
        // 内部ノードに対してもこれを行うことができます。
        fn fold_name(&mut self, n: Box<Name>) -> Box<Name> { n }
        // 子をfoldすることで新しい内部ノードを作成します。
        fn fold_stmt(&mut self, s: Box<Stmt>) -> Box<Stmt> {
            match *s {
                Stmt::Expr(e) => Box::new(Stmt::Expr(self.fold_expr(e))),
                Stmt::Let(n, e) => Box::new(Stmt::Let(self.fold_name(n), self.fold_expr(e))),
            }
        }
        fn fold_expr(&mut self, e: Box<Expr>) -> Box<Expr> { ... }
    }
}

use fold::*;
use ast::*;

// 具体的な実装例 - すべての名前を'foo'に変更します。
struct Renamer;
impl Folder for Renamer {
    fn fold_name(&mut self, n: Box<Name>) -> Box<Name> {
        Box::new(Name { value: "foo".to_owned() })
    }
    // 他のノードにはデフォルトメソッドを使用します。
}
```

AST上で`Renamer`を実行した結果は、古いものと同一の新しいASTですが、
すべての名前が`foo`に変更されています。実際のfolderは、構造体自体にノード間で
保持される状態を持つかもしれません。

folderは、あるデータ構造を異なる（しかし通常は類似した）データ構造にマップするように
定義することもできます。例えば、ASTをHIRツリーにfoldできます
（HIRは高レベル中間表現の略です）。

## 動機

構造内の各ノードに対して何らかの操作を実行してデータ構造をマップしたいというのは一般的です。
単純なデータ構造に対する単純な操作の場合、これは`Iterator::map`を使用して実行できます。
より複雑な操作、おそらく以前のノードが後のノードの操作に影響を与える場合、
またはデータ構造に対する反復が自明でない場合は、foldパターンを使用する方が適切です。

ビジターパターンと同様に、foldパターンにより、データ構造の走査と各ノードに対して実行される
操作を分離できます。

## 議論

この方法でデータ構造をマッピングすることは、関数型言語では一般的です。
OO言語では、データ構造をその場で変更する方が一般的です。
「関数型」アプローチはRustでは一般的であり、主に不変性を好むためです。
古いデータ構造を変更するのではなく、新しいデータ構造を使用すると、
ほとんどの状況でコードの推論が容易になります。

効率性と再利用性のトレードオフは、`fold_*`メソッドがノードを受け入れる方法を
変更することで調整できます。

上記の例では、`Box`ポインタで操作しています。これらはデータを排他的に所有するため、
データ構造の元のコピーは再利用できません。一方、ノードが変更されない場合、
それを再利用することは非常に効率的です。

借用参照で操作する場合、元のデータ構造を再利用できます。
ただし、変更されない場合でもノードをクローンする必要があり、これは高価になる可能性があります。

参照カウントポインタを使用すると、両方の長所が得られます - 元のデータ構造を再利用でき、
変更されないノードをクローンする必要がありません。ただし、使用するのが人間工学的でなく、
データ構造が可変にできないことを意味します。

## 参照

イテレータには`fold`メソッドがありますが、これはデータ構造を新しいデータ構造ではなく
値にfoldします。イテレータの`map`は、このfoldパターンに似ています。

他の言語では、foldは通常、このパターンではなく、Rustのイテレータの意味で使用されます。
一部の関数型言語には、データ構造に対して柔軟なマップを実行するための強力な構造があります。

[ビジター](../behavioural/visitor.md)パターンはfoldと密接に関連しています。
これらは、各ノードで操作を実行してデータ構造を走査するという概念を共有しています。
ただし、ビジターは新しいデータ構造を作成せず、古いものを消費しません。