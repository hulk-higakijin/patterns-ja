# `Deref`ポリモーフィズム

## 説明

構造体間の継承をエミュレートするために`Deref`トレイトを誤用し、
メソッドを再利用します。

## 例

時々、Javaのような　OO言語の以下の一般的なパターンをエミュレートしたいと思うことがあります：

```java
class Foo {
    void m() { ... }
}

class Bar extends Foo {}

public static void main(String[] args) {
    Bar b = new Bar();
    b.m();
}
```

derefポリモーフィズムアンチパターンを使用してこれを行うことができます：

```rust
use std::ops::Deref;

struct Foo {}

impl Foo {
    fn m(&self) {
        //..
    }
}

struct Bar {
    f: Foo,
}

impl Deref for Bar {
    type Target = Foo;
    fn deref(&self) -> &Foo {
        &self.f
    }
}

fn main() {
    let b = Bar { f: Foo {} };
    b.m();
}
```

Rustには構造体継承がありません。代わりに、コンポジションを使用して`Bar`に`Foo`のインスタンスを含めます
（フィールドが値であるため、インラインで格納されるので、フィールドがあれば、
Javaバージョンと同じメモリレイアウトを持つでしょう（おそらく、確実にしたければ`#[repr(C)]`を使用すべきです））。

メソッド呼び出しを機能させるために、`Foo`をターゲットとして`Bar`に`Deref`を実装します
（埋め込まれた`Foo`フィールドを返します）。これは、`Bar`を逆参照すると（例えば、`*`を使用）、
`Foo`を取得することを意味します。これはかなり奇妙です。
通常、逆参照は`T`への参照から`T`を与えますが、ここでは関連のない2つの型があります。
しかし、ドット演算子は暗黙的な逆参照を行うため、メソッド呼び出しは`Bar`だけでなく`Foo`のメソッドも検索することを意味します。

## 利点

少しのボイラープレートを節約できます。例：

```rust,ignore
impl Bar {
    fn m(&self) {
        self.f.m()
    }
}
```

## 欠点

最も重要なことは、これは驚くべきイディオムであることです - 
将来このコードを読むプログラマーは、これが起こることを期待しないでしょう。
それは、意図された（そして文書化された）通りに使用するのではなく、
`Deref`トレイトを誤用しているからです。また、ここでのメカニズムが完全に暗黙的だからでもあります。

このパターンは、JavaやC++の継承のように`Foo`と`Bar`間のサブタイピングを導入しません。
さらに、`Foo`によって実装されたトレイトは`Bar`に自動的に実装されないため、
このパターンは境界チェックと悪い相互作用をし、したがってジェネリックプログラミングに影響を与えます。

このパターンを使用すると、`self`に関してほとんどのOO言語とは微妙に異なるセマンティクスを与えます。
通常はサブクラスへの参照のままですが、このパターンではメソッドが定義される「クラス」になります。

最後に、このパターンは単一継承のみをサポートし、インターフェース、クラスベースのプライバシー、
その他の継承関連機能の概念がありません。したがって、Java継承などに慣れたプログラマーには
微妙に驚くべき経験を与えます。

## 議論

一つの良い代替案はありません。正確な状況によっては、
トレイトを使用して再実装するか、`Foo`に手動でディスパッチするファサードメソッドを書き出す方が良いかもしれません。
これに似た継承メカニズムをRustに追加する意図はありますが、
安定版Rustに到達するまでにはしばらく時間がかかりそうです。詳細については、
これらの[ブログ](http://aturon.github.io/blog/2015/09/18/reuse/)
[記事](http://smallcultfollowing.com/babysteps/blog/2015/10/08/virtual-structs-part-4-extended-enums-and-thin-traits/)
およびこの[RFC issue](https://github.com/rust-lang/rfcs/issues/349)を参照してください。

`Deref`トレイトは、カスタムポインタ型の実装のために設計されています。
意図は、`T`へのポインタを`T`に変換することであり、異なる型間の変換ではありません。
これがトレイト定義によって強制されない（おそらくできない）のは残念です。

Rustは、明示的および暗黙的メカニズム間の慎重なバランスを取ろうとし、
型間の明示的変換を好みます。ドット演算子での自動逆参照は、
人間工学が暗黙的メカニズムを強く好む場合ですが、
意図は、これが間接化の度合いに限定され、任意の型間の変換ではないということです。

## 参照

- [コレクションはスマートポインタイディオム](../idioms/deref.md)。
- [delegate](https://crates.io/crates/delegate)や
  [ambassador](https://crates.io/crates/ambassador)などの少ないボイラープレートのための委譲クレート
- [`Deref`トレイトのドキュメント](https://doc.rust-lang.org/std/ops/trait.Deref.html)。
