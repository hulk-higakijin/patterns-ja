# プログラミングパラダイム

命令型の背景から関数型プログラムを理解する際の最大の障害の一つは、思考の転換です。命令型プログラムは**どのように**何かを行うかを記述しますが、宣言型プログラムは**何を**行うかを記述します。これを示すため、1から10までの数を合計してみましょう。

## 命令型

```rust
let mut sum = 0;
for i in 1..11 {
    sum += i;
}
println!("{sum}");
```

命令型プログラムでは、何が起こっているかを見るためにコンパイラーの役割を果たさなければなりません。ここでは、`sum`を`0`で開始します。次に、1から10までの範囲を反復処理します。ループを通るたびに、範囲内の対応する値を追加します。そして結果を出力します。

| `i` | `sum` |
| :-: | :---: |
|  1  |   1   |
|  2  |   3   |
|  3  |   6   |
|  4  |  10   |
|  5  |  15   |
|  6  |  21   |
|  7  |  28   |
|  8  |  36   |
|  9  |  45   |
| 10  |  55   |

これは私たちの多くがプログラミングを始める方法です。プログラムは一連のステップであることを学びます。

## 宣言型

```rust
println!("{}", (1..11).fold(0, |a, b| a + b));
```

わあ！これは本当に違います！ここで何が起こっているのでしょうか？宣言型プログラムでは、**どのように**行うかではなく、**何を**行うかを記述することを思い出してください。`fold`は関数を[合成](https://en.wikipedia.org/wiki/Function_composition)する関数です。この名前はHaskellの慣習です。

ここでは、1から10の範囲で加算の関数（このクロージャ：`|a, b| a + b`）を合成しています。`0`が開始点なので、最初は`a`は`0`です。`b`は範囲の最初の要素、`1`です。`0 + 1 = 1`が結果です。そこで今度は`a = 1`、`b = 2`で再び`fold`し、`1 + 2 = 3`が次の結果になります。このプロセスは範囲の最後の要素`10`に到達するまで続きます。

| `a` | `b` | result |
| :-: | :-: | :----: |
|  0  |  1  |   1    |
|  1  |  2  |   3    |
|  3  |  3  |   6    |
|  6  |  4  |   10   |
| 10  |  5  |   15   |
| 15  |  6  |   21   |
| 21  |  7  |   28   |
| 28  |  8  |   36   |
| 36  |  9  |   45   |
| 45  | 10  |   55   |
