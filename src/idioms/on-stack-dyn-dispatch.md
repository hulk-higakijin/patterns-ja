# スタック上での動的ディスパッチ

## 説明

複数の値で動的ディスパッチを行うことができますが、そのためには
異なる型のオブジェクトをバインドするために複数の変数を宣言する必要があります。
必要に応じてライフタイムを延長するために、以下に示すように
遅延条件初期化を使用できます：

## 例

```rust
use std::io;
use std::fs;

# fn main() -> Result<(), Box<dyn std::error::Error>> {
# let arg = "-";

// 動的ディスパッチを得るために型を記述する必要があります。
let readable: &mut dyn io::Read = if arg == "-" {
    &mut io::stdin()
} else {
    &mut fs::File::open(arg)?
};

// ここで`readable`から読み取ります。

# Ok(())
# }
```

## 動機

Rustはデフォルトでコードを単相化します。これは、使用される各型に対してコードのコピーが
生成され、独立して最適化されることを意味します。これにより
ホットパスで非常に高速なコードが可能になりますが、パフォーマンスが本質的でない場所で
コードを肥大化させ、コンパイル時間とキャッシュ使用量を犠牲にします。

幸い、Rustは動的ディスパッチを使用することを許可していますが、
明示的に要求する必要があります。

## 利点

ヒープ上に何も割り当てる必要がありません。後で使用しないものを
初期化する必要もありませんし、`File`と`Stdin`の両方で動作するように
後に続く全コードを単相化する必要もありません。

## 欠点

Rust 1.79.0以前は、コードは遅延初期化を伴う2つの`let`バインディングを必要とし、
これは`Box`ベースのバージョンよりも多くの可動部分を構成していました：

```rust,ignore
// 動的ディスパッチのために型を付与する必要があります。
let readable: Box<dyn io::Read> = if arg == "-" {
    Box::new(io::stdin())
} else {
    Box::new(fs::File::open(arg)?)
};
// ここで`readable`から読み取ります。
```

幸い、この欠点はなくなりました。やったね！

## 議論

Rust 1.79.0以降、コンパイラは関数のスコープ内で可能な限り
`&`または`&mut`内の一時的な値のライフタイムを自動的に延長します。

これは、内容を何らかの`let`バインディングに配置することを心配せずに
ここで`&mut`値を単純に使用できることを意味します（これは遅延初期化に必要だったもので、
その変更前に使用されていた解決策でした）。

各値にはまだ場所があり（その場所が一時的であっても）、コンパイラは
各値のサイズを知っており、各借用された値はそこから借用されたすべての
参照よりも長生きします。

## 関連項目

- [デストラクタでの最終処理](dtor-finally.md)と
  [RAIIガード](../patterns/behavioural/RAII.md)は、ライフタイムの厳密な制御から
  恩恵を受けることができます。
- （可変）参照の条件的に満たされた`Option<&T>`については、
  `Option<T>`を直接初期化し、その[`.as_ref()`]メソッドを使用して
  オプション参照を取得できます。

[`.as_ref()`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref
