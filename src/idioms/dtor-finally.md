# デストラクタでの最終処理

## 説明

Rustは`finally`ブロックの等価な機能を提供していません -
関数がどのような方法で終了しても
実行されるコードのことです。代わりに、オブジェクトのデストラクタを使用して、
終了前に実行しなければならないコードを実行できます。

## 例

```rust,ignore
fn baz() -> Result<(), ()> {
    // some code
}

fn bar() -> Result<(), ()> {
    // これらは関数内で定義する必要はありません。
    struct Foo;

    // Fooのデストラクタを実装。
    impl Drop for Foo {
        fn drop(&mut self) {
            println!("exit");
        }
    }

    // 関数`bar`がどのように終了しても_exitのdtorが実行される。
    let _exit = Foo;
    // `?`演算子による暗黙の戻り。
    baz()?;
    // 通常の戻り。
    Ok(())
}
```

## 動機

関数に複数の戻り点がある場合、終了時にコードを実行することは
困難で反復的（つまりバグが発生しやすく）になります。これは特に
マクロによって戻りが暗黙的である場合に当てはまります。一般的なケースは`?`演算子で、
結果が`Err`の場合は戻り、`Ok`の場合は続行します。`?`は
例外処理メカニズムとして使用されますが、Java（`finally`がある）とは異なり、
通常の場合と例外的な場合の両方でコードを実行するようにスケジュールする方法がありません。
パニックも関数を早期に終了させます。

## 利点

デストラクタ内のコードは（ほぼ）常に実行されます - パニック、早期
戻りなどに対応します。

## 欠点

デストラクタが実行されることは保証されていません。例えば、関数内で
無限ループがある場合や、関数の実行が終了前にクラッシュした場合です。
デストラクタは、すでにパニックしているスレッドでのパニックの場合にも実行されません。
したがって、最終処理が絶対に不可欠な場合、デストラクタをファイナライザーとして
頼ることはできません。

このパターンは、気づきにくい暗黙的なコードを導入します。関数を読んでも
終了時に実行されるデストラクタの明確な指示は得られません。これは
デバッグを困難にする可能性があります。

最終処理のためだけにオブジェクトと`Drop`実装を必要とするのは
ボイラープレートが重いです。

## 議論

ファイナライザーとして使用するオブジェクトを正確にどのように保存するかについて
いくつかの微妙な点があります。関数の終了まで生かしておき、その後
破棄されなければなりません。オブジェクトは常に値または一意に所有されたポインタ（例：
`Box<Foo>`）でなければなりません。共有ポインタ（`Rc`など）が使用される場合、
ファイナライザーは関数のライフタイムを超えて生かしておくことができます。同様の理由で、
ファイナライザーは移動したり返したりしてはいけません。

ファイナライザーは変数に代入しなければなりません。そうでなければ、
スコープから外れたときではなく、すぐに破棄されます。変数がファイナライザーとしてのみ
使用される場合、変数名は`_`で始まらなければなりません。そうでなければコンパイラは
ファイナライザーが使用されていないと警告します。ただし、変数を
サフィックスなしの`_`と呼んではいけません - その場合すぐに破棄されます。

Rustでは、オブジェクトがスコープから外れるときにデストラクタが実行されます。これは
ブロックの終わりに到達するか、早期戻りがあるか、プログラムが
パニックするかにかかわらず発生します。パニック時、Rustは各スタックフレーム内の
各オブジェクトのデストラクタを実行してスタックを巻き戻します。したがって、呼び出されている
関数でパニックが発生してもデストラクタは呼び出されます。

巻き戻し中にデストラクタがパニックした場合、取るべき良いアクションがないため、Rustは
それ以上のデストラクタを実行することなく、すぐにスレッドを中止します。これは
デストラクタが絶対に実行されることが保証されていないことを意味します。また、
リソースを予期しない状態に残す可能性があるため、デストラクタでパニックしないよう
特別な注意を払わなければならないことも意味します。

## 関連項目

[RAIIガード](../patterns/behavioural/RAII.md)。
